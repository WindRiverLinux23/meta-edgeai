From 3594669cebdc28906243eb7145e65443fdcfaabf Mon Sep 17 00:00:00 2001
From: Rahul T R <r-ravikumar@ti.com>
Date: Thu, 12 Oct 2023 18:17:21 +0530
Subject: [PATCH] gstkmssink: Add support to use multiple kmssinks

By setting and dropping master in a critical section for all
previlaged drm calls
Note that this might have some performence impact since
drmModeSetPlane happens every frame and this needs set master

Signed-off-by: Rahul T R <r-ravikumar@ti.com>
---
 sys/kms/gstkmssink.c | 40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/sys/kms/gstkmssink.c b/sys/kms/gstkmssink.c
index 788cefc..b0dd97d 100644
--- a/sys/kms/gstkmssink.c
+++ b/sys/kms/gstkmssink.c
@@ -102,6 +102,8 @@ enum
 
 static GParamSpec *g_properties[PROP_N] = { NULL, };
 
+static GMutex gst_kms_sink_drm_master_mutex = { 0 };
+
 static void
 gst_kms_sink_set_render_rectangle (GstVideoOverlay * overlay,
     gint x, gint y, gint width, gint height)
@@ -466,8 +468,15 @@ configure_mode_setting (GstKMSSink * self, GstVideoInfo * vinfo)
   if (!mode)
     goto mode_failed;
 
+  g_mutex_lock (&gst_kms_sink_drm_master_mutex);
+  drmSetMaster(self->fd);
+
   err = drmModeSetCrtc (self->fd, self->crtc_id, fb_id, 0, 0,
       (uint32_t *) & self->conn_id, 1, mode);
+
+  drmDropMaster(self->fd);
+  g_mutex_unlock (&gst_kms_sink_drm_master_mutex);
+
   if (err)
     goto modesetting_failed;
 
@@ -605,12 +614,18 @@ set_drm_property (gint fd, guint32 object, guint32 object_type,
 
     GST_LOG ("found property %s (looking for %s)", property->name, prop_name);
 
+    g_mutex_lock (&gst_kms_sink_drm_master_mutex);
+    drmSetMaster(fd);
+
     if (!strcmp (property->name, prop_name)) {
       drmModeObjectSetProperty (fd, object, object_type,
           property->prop_id, value);
       ret = TRUE;
     }
     drmModeFreeProperty (property);
+
+    drmDropMaster(fd);
+    g_mutex_unlock (&gst_kms_sink_drm_master_mutex);
   }
 
   return ret;
@@ -729,10 +744,16 @@ gst_kms_sink_start (GstBaseSink * bsink)
   pres = NULL;
   plane = NULL;
 
+  g_mutex_lock (&gst_kms_sink_drm_master_mutex);
+
   if (self->devname || self->bus_id)
     self->fd = drmOpen (self->devname, self->bus_id);
   else
     self->fd = kms_open (&self->devname);
+
+  drmDropMaster(self->fd);
+  g_mutex_unlock (&gst_kms_sink_drm_master_mutex);
+
   if (self->fd < 0)
     goto open_failed;
 
@@ -934,6 +955,9 @@ gst_kms_sink_stop (GstBaseSink * bsink)
   if (self->saved_crtc) {
     drmModeCrtc *crtc = (drmModeCrtc *) self->saved_crtc;
 
+    g_mutex_lock (&gst_kms_sink_drm_master_mutex);
+    drmSetMaster(self->fd);
+
     err = drmModeSetCrtc (self->fd, crtc->crtc_id, crtc->buffer_id, crtc->x,
         crtc->y, (uint32_t *) & self->conn_id, 1, &crtc->mode);
     if (err)
@@ -942,6 +966,9 @@ gst_kms_sink_stop (GstBaseSink * bsink)
 
     drmModeFreeCrtc (crtc);
     self->saved_crtc = NULL;
+
+    drmDropMaster(self->fd);
+    g_mutex_unlock (&gst_kms_sink_drm_master_mutex);
   }
 
   if (self->fd >= 0) {
@@ -1294,8 +1321,14 @@ gst_kms_sink_sync (GstKMSSink * self)
     if (ret)
       goto vblank_failed;
   } else {
+    g_mutex_lock (&gst_kms_sink_drm_master_mutex);
+    drmSetMaster(self->fd);
+
     ret = drmModePageFlip (self->fd, self->crtc_id, self->buffer_id,
         DRM_MODE_PAGE_FLIP_EVENT, &waiting);
+
+    drmDropMaster(self->fd);
+    g_mutex_unlock (&gst_kms_sink_drm_master_mutex);
     if (ret)
       goto pageflip_failed;
   }
@@ -1662,10 +1695,17 @@ retry_set_plane:
       "drmModeSetPlane at (%i,%i) %ix%i sourcing at (%i,%i) %ix%i",
       result.x, result.y, result.w, result.h, src.x, src.y, src.w, src.h);
 
+  g_mutex_lock (&gst_kms_sink_drm_master_mutex);
+  drmSetMaster(self->fd);
+
   ret = drmModeSetPlane (self->fd, self->plane_id, self->crtc_id, fb_id, 0,
       result.x, result.y, result.w, result.h,
       /* source/cropping coordinates are given in Q16 */
       src.x << 16, src.y << 16, src.w << 16, src.h << 16);
+
+  drmDropMaster(self->fd);
+  g_mutex_unlock (&gst_kms_sink_drm_master_mutex);
+
   if (ret) {
     if (self->can_scale) {
       self->can_scale = FALSE;
-- 
2.34.1

